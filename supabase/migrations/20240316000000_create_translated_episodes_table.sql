CREATE TABLE translated_episodes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    podcast_id UUID NOT NULL REFERENCES podcasts(id) ON DELETE CASCADE,
    language_code VARCHAR(10) NOT NULL,
    voice_name VARCHAR(255) NOT NULL,
    audio_storage_path TEXT NOT NULL,
    file_size BIGINT,
    duration_seconds INT,
    status VARCHAR(50) NOT NULL DEFAULT 'pending', -- e.g., pending, completed, failed
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- To associate who generated it, optional

    CONSTRAINT uq_podcast_lang_voice UNIQUE (podcast_id, language_code, voice_name) -- Avoid duplicate entries
);

-- Optional: Add indexes for frequently queried columns
CREATE INDEX IF NOT EXISTS idx_translated_episodes_podcast_id ON translated_episodes(podcast_id);
CREATE INDEX IF NOT EXISTS idx_translated_episodes_language_code ON translated_episodes(language_code);
CREATE INDEX IF NOT EXISTS idx_translated_episodes_status ON translated_episodes(status);

-- RLS (Row Level Security)
-- Enable RLS for the table
ALTER TABLE translated_episodes ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select their own translated episodes
CREATE POLICY "Allow individual user select access"
ON translated_episodes
FOR SELECT
USING (auth.uid() = user_id);

-- Policy: Allow users to insert their own translated episodes
-- Note: The user_id in the function will be derived from the JWT or passed in.
-- The function itself runs with service_role bypasses RLS for insertion if needed,
-- but it's good practice to have policies if direct client inserts were ever allowed.
-- For now, assuming inserts are done via a service_role key in the TTS function,
-- so an INSERT policy for users might not be strictly necessary IF user_id is set by the function.
-- If user_id is to be auth.uid() automatically on insert from client, then:
-- CREATE POLICY "Allow individual user insert access"
-- ON translated_episodes
-- FOR INSERT
-- WITH CHECK (auth.uid() = user_id);

-- For functions operating with service_role, they can bypass RLS.
-- If downloads are proxied through a function, that function can check ownership.
-- If using signed URLs generated by a function, that function also checks ownership.

COMMENT ON COLUMN translated_episodes.status IS 'Status of the translated episode generation (e.g., completed, failed, processing)';
COMMENT ON CONSTRAINT uq_podcast_lang_voice ON translated_episodes IS 'Ensures that for a given podcast, a specific language and voice combination is unique.';
